<!DOCTYPE html>
<html lang="de">
<head>
    <link rel="icon" type="image/x-icon" href="icon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&display=swap"
          rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escape the lifetime sentence</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: "Chakra Petch", sans-serif;
            font-weight: 400;
            font-style: normal;
        }

        #game {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #8B4513; /* Bodenfarbe */
            background-image: url("flor.jpg");
            background-size: cover;
        }

        #player {
            position: absolute;
            width: calc(2vw + 2vh);
            height: calc(2vw + 2vh);
            background-color: red;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-image: url('schoel.jfif'); /* Hintergrundbild hinzufügen */
            background-size: cover; /* Bild auf die gesamte Größe des Elements skalieren */
        }

        #timer {
            position: absolute;
            top: 1vh;
            right: 1vw;
            width: 10vw;
            height: 8vh;
            padding: calc(0.3vh + 0.3vw);
            background-color: #333;
            color: #fff;
            font-size: calc(2vw + 3vh);
            border-radius: calc(1vh + 1vw);
            text-align: center;
            z-index: 1000; /* Beispielwert, je höher der Wert, desto weiter vorne liegt das Element */
        }

        .obstacle {
            position: absolute;
            width: calc(3vw + 3vh);
            height: calc(3vw + 3vh);
            background-color: green;
            animation-duration: 2s;
            animation-iteration-count: infinite;
            animation-timing-function: linear;
            background-image: url('polis.png'); /* Hintergrundbild hinzufügen */
            background-size: cover; /* Bild auf die gesamte Größe des Elements skalieren */
        }

        @keyframes moveHorizontalFromRight {
            0% {
                left: 100vw;
            }
            100% {
                left: calc(-4vw - 3vh);
            }
        }

        @keyframes moveVerticalFromTop {
            0% {
                top: calc(-4vw + -3vh);
            }
            100% {
                top: 100vh;
            }
        }

        @keyframes moveHorizontalFromLeft {
            0% {
                left: calc(-4vw + -3vh);
            }
            100% {
                left: 100vw;
            }
        }

        @keyframes moveVerticalFromBottom {
            0% {
                top: 100vh;
            }
            100% {
                top: calc(-4vw + -3vh);
            }
        }
    </style>
</head>
<body>
<div id="game">
    <div id="player"></div>
    <div id="timer"></div>
</div>
<script>
    document.addEventListener('DOMContentLoaded', function () {
        const game = document.getElementById('game');
        const player = document.getElementById('player');
        let previousPositionTop = 50;
        let previousPositionLeft = 50;
        let moveSpeed = 0.2; // Geschwindigkeit in vw und vh
        let max = 3000;
        let min = max - 500;
        let firstMove = true;
        let seconds = 0;
        let minutes = 0;
        let playTime = 0;
        let firstTimeHandler = true;
        let randNumber;
        let aidsTimeout = 50;
        let keys = {
            w: false,
            a: false,
            s: false,
            d: false
        };

        let timerInterval;
        let obstacleInterval;

        function addLeadingZero(num) {
            return num < 10 ? '0' + num : num;
        }

        function startTimer() {
            timerInterval = setInterval(updateTimer, 1000);
        }

        function obstacleHandler() {
            if (firstTimeHandler) {
                max = 1.5 - (playTime / 25);
                if (max <= 0.2) {
                    max = 0.2;
                }
                if(playTime >= 90){
                    max = 0.14;
                }
                max *= 100;
                min = max - 5;
                firstTimeHandler = false;
                randNumber = Math.round(Math.random() * (max - min) + min);
            }
            randNumber--;
            if (randNumber === 0) {
                firstTimeHandler = true;
                createObstacle();
            }
        }

        function updateTimer() {
            seconds++;
            if (seconds === 60) {
                seconds = 0;
                minutes++;
                if (minutes <= 9) {
                    minutes = addLeadingZero(minutes);
                }
            }
            moveSpeed = 0.3 + (playTime / 100);
            if (moveSpeed >= 1.6) {
                moveSpeed = 1.6;
            }
            playTime = (minutes * 60) + seconds;
            seconds = addLeadingZero(seconds);
            document.getElementById('timer').textContent = '';
            document.getElementById('timer').append(minutes + ":" + seconds);
            if (playTime === 40) {
                setInterval(aids, 10);
            }
        }

        function movePlayer() {
            if (firstMove) {
                startTimer();
                firstMove = false;
            }
            let playerTop = parseFloat(player.style.top) || previousPositionTop;
            let playerLeft = parseFloat(player.style.left) || previousPositionLeft;
            let playerHeight = parseFloat(player.style.height) || 0;
            let playerWidth = parseFloat(player.style.width) || 0;

            previousPositionTop = parseFloat(player.style.top);
            previousPositionLeft = parseFloat(player.style.left);

            if (keys.w) {
                playerTop = Math.max(0, playerTop - (moveSpeed + 0.2));
            }
            if (keys.a) {
                playerLeft = Math.max(0, playerLeft - moveSpeed);
            }
            if (keys.s) {
                playerTop = Math.min(100 - (playerHeight / window.innerHeight * 100), playerTop + (moveSpeed + 0.2));
            }
            if (keys.d) {
                playerLeft = Math.min(100 - (playerWidth / window.innerWidth * 100), playerLeft + moveSpeed);
            }

            player.style.top = `${playerTop}vh`;
            player.style.left = `${playerLeft}vw`;

            requestAnimationFrame(movePlayer);
        }

        function createObstacle() {
            const obstacle = document.createElement('div');
            obstacle.classList.add('obstacle');
            // Zufällige Auswahl einer Bewegungsrichtung für das Hindernis
            const direction = Math.floor(Math.random() * 4); // 0 bis 3
            switch (direction) {
                case 0: // Von oben
                    obstacle.style.top = 'calc(-4vw + -3vh)';
                    obstacle.style.left = `${Math.random() * 100}vw`;
                    obstacle.style.animationName = 'moveVerticalFromTop';
                    break;
                case 1: // Von rechts
                    obstacle.style.top = `${Math.random() * 100}vh`;
                    obstacle.style.left = '100vw';
                    obstacle.style.animationName = 'moveHorizontalFromRight';
                    break;
                case 2: // Von unten
                    obstacle.style.top = '100vh';
                    obstacle.style.left = `${Math.random() * 100}vw`;
                    obstacle.style.animationName = 'moveVerticalFromBottom';
                    break;
                case 3: // Von links
                    obstacle.style.top = `${Math.random() * 100}vh`;
                    obstacle.style.left = 'calc(-4vw + -3vh)';
                    obstacle.style.animationName = 'moveHorizontalFromLeft';
                    break;
            }
            let duration = (2.5 - (playTime / 60));
            duration = duration + 1.2;
            if (duration <= 1.2) {
                duration = 1.2;
            }
            if ((direction === 1) || (direction === 3)) {
                duration += 0.2;
            }
            obstacle.style.animationDuration = duration + 's';

            game.appendChild(obstacle);
            setTimeout(() => {
                obstacle.remove();
            }, duration * 1000);
        }

        document.addEventListener('keydown', event => {
            if (event.code === 'KeyW') {
                keys.w = true;
            }
            if (event.code === 'KeyA') {
                keys.a = true;
            }
            if (event.code === 'KeyS') {
                keys.s = true;
            }
            if (event.code === 'KeyD') {
                keys.d = true;
            }
        });

        document.addEventListener('keyup', event => {
            if (event.code === 'KeyW') {
                keys.w = false;
            }
            if (event.code === 'KeyA') {
                keys.a = false;
            }
            if (event.code === 'KeyS') {
                keys.s = false;
            }
            if (event.code === 'KeyD') {
                keys.d = false;
            }
        });

        function aids() {
            document.getElementById("game").style.filter = 'invert(1)';
            setTimeout(function () {
                document.getElementById("game").style.filter = 'invert(0)';
            }, aidsTimeout);
            setTimeout(function () {
                document.getElementById("game").style.filter = 'invert(1)';
            }, 2 * aidsTimeout);
            setTimeout(function () {
                document.getElementById("game").style.filter = 'invert(0)';
            }, 3 * aidsTimeout);
            setTimeout(function () {
                document.getElementById("game").style.filter = 'invert(1)';
            }, 4 * aidsTimeout);
            setTimeout(function () {
                document.getElementById("game").style.filter = 'invert(0)';
            }, 5 * aidsTimeout);
        }

        function gameLoop() {
            const playerRect = player.getBoundingClientRect();
            document.querySelectorAll('.obstacle').forEach(obstacle => {
                const obstacleRect = obstacle.getBoundingClientRect();
                if (
                    playerRect.left < obstacleRect.left + obstacleRect.width &&
                    playerRect.left + playerRect.width > obstacleRect.left &&
                    playerRect.top < obstacleRect.top + obstacleRect.height &&
                    playerRect.top + playerRect.height > obstacleRect.top
                ) {
                    alert('ded');
                    location.reload();
                }
            });
            requestAnimationFrame(gameLoop);
        }

        function pauseGame() {
            clearInterval(timerInterval);
        }

        function resumeGame() {
            timerInterval = setInterval(updateTimer, 1000);
        }

        document.addEventListener('visibilitychange', function () {
            if (document.hidden) {
                pauseGame();
            } else {
                resumeGame();
            }
        });

        obstacleInterval = setInterval(obstacleHandler, 10);
        movePlayer();
        gameLoop();
    });
</script>
</body>
</html>